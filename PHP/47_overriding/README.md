[//]: # (This file is automatically generated. If you wish to make any changes, please use the JSON files and regenerate this file using the tpframework.)

# Overriding

Tags: sast, php, php_v7.4.9

Version: v1.0

## Description

A child class can override a method from a parent class by implementing this function with the same parameters and the same return type.

## Overview

| Instances                 | has discovery rule   | discovery method   | rule successfull   |
|---------------------------|----------------------|--------------------|--------------------|
| [1 Instance](#1-instance) | yes                  | joern              | no                 |
| [2 Instance](#2-instance) | yes                  | joern              | no                 |

<details markdown="1"open>
<summary>

## 1 Instance
</summary>

This instance shows an inheritance construct, where both parent and child class implement the same function. An object of the parent class is instantiated and the function is called on that object. As it is an object of the parent class this instance is vulnerable.

### Code

```PHP
<?php
class parent_class {
    function F($b) {
       return $b;
    }
}

class child_class extends parent_class {
    function F($b) {
        return "safe";
     }
}

$b = $_GET['p1']; // source
$obj = new parent_class();
$a = $obj->F($b);
echo $a; // sink
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| S0         | FEATURE                   | no                | no                   | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=12, args=0, vars=3, tmps=8)
     ; (before optimizer)
     ; /.../PHP/47_overriding/1_instance_47_overriding/1_instance_47_overriding.php:1-18
     ; return  [] RANGE[0..0]
0000 T3 = FETCH_R (global) string("_GET")
0001 T4 = FETCH_DIM_R T3 string("p1")
0002 ASSIGN CV0($b) T4
0003 V6 = NEW 0 string("parent_class")
0004 DO_FCALL
0005 ASSIGN CV1($obj) V6
0006 INIT_METHOD_CALL 1 CV1($obj) string("F")
0007 SEND_VAR_EX CV0($b) 1
0008 V9 = DO_FCALL
0009 ASSIGN CV2($a) V9
0010 ECHO CV2($a)
0011 RETURN int(1)
LIVE RANGES:
     6: 0004 - 0005 (new)

parent_class::F:
     ; (lines=3, args=1, vars=1, tmps=0)
     ; (before optimizer)
     ; /.../PHP/47_overriding/1_instance_47_overriding/1_instance_47_overriding.php:3-5
     ; return  [] RANGE[0..0]
0000 CV0($b) = RECV 1
0001 RETURN CV0($b)
0002 RETURN null

child_class::F:
     ; (lines=3, args=1, vars=1, tmps=0)
     ; (before optimizer)
     ; /.../PHP/47_overriding/1_instance_47_overriding/1_instance_47_overriding.php:9-11
     ; return  [] RANGE[0..0]
0000 CV0($b) = RECV 1
0001 RETURN string("safe")
0002 RETURN null
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

The rule would be perfect, if we could check for inheritance. This instance might profid from source code discovery.

```scala
// Get all classes and all the methods within this classes as a list of arrays with two elements [[<class>, <method>], [<class>, <method>]]
val allClassesAndMethods = cpg.method.astParentType("TYPE_DECL").fullName.l.map(x => x.split("::")).filter(x => x.length > 1)
// Get all classnames, that implement the same method as any other class
val classNames = allClassesAndMethods.flatMap(a => allClassesAndMethods.filter(b => b(1) == a(1) && b(0) != a(0)).map(b => (a(0), b(1)))).toSet
val x47 = (name, "47_overriding_iall", cpg.method.filter(node => classNames.contains((node.astParentFullName, node.name))).location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | FP                  |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Comm_2   | phpSAFE   | Progpilot   | RIPS   | WAP   | Ground Truth   |
|-------------|----------|----------|-----------|-------------|--------|-------|----------------|
| 08 Jun 2021 | yes      | yes      | no        | yes         | no     | no    | yes            |
| 22 May 2023 | yes      | yes      |           |             |        |       | yes            |

</details>

</details>

</details>

<details markdown="1">
<summary>

## 2 Instance
</summary>

This instance is similar to the previous instance. The difference is, that this time the object is instantiated from the child class and the function in the child class is not vulnerable.

### Code

```PHP
<?php
class parent_class {
    function F($b) {
       return $b;
    }
}

class child_class extends parent_class {
    function F($b) {
        return "safe";
     }
}

$b = $_GET['p1']; // source
$obj = new child_class();
// The F of child_class is called, so no XSS
$a = $obj->F($b);
echo $a; // sink
```

### Instance Properties

| category   | feature_vs_internal_api   | input_sanitizer   | negative_test_case   | source_and_sink   |
|------------|---------------------------|-------------------|----------------------|-------------------|
| S0         | FEATURE                   | no                | no                   | no                |

<details markdown="1">
<summary>
<b>More</b></summary>

<details markdown="1">
<summary>

### Compile
</summary>

```bash
$_main:
     ; (lines=12, args=0, vars=3, tmps=8)
     ; (before optimizer)
     ; /.../PHP/47_overriding/2_instance_47_overriding/2_instance_47_overriding.php:1-19
     ; return  [] RANGE[0..0]
0000 T3 = FETCH_R (global) string("_GET")
0001 T4 = FETCH_DIM_R T3 string("p1")
0002 ASSIGN CV0($b) T4
0003 V6 = NEW 0 string("child_class")
0004 DO_FCALL
0005 ASSIGN CV1($obj) V6
0006 INIT_METHOD_CALL 1 CV1($obj) string("F")
0007 SEND_VAR_EX CV0($b) 1
0008 V9 = DO_FCALL
0009 ASSIGN CV2($a) V9
0010 ECHO CV2($a)
0011 RETURN int(1)
LIVE RANGES:
     6: 0004 - 0005 (new)

parent_class::F:
     ; (lines=3, args=1, vars=1, tmps=0)
     ; (before optimizer)
     ; /.../PHP/47_overriding/2_instance_47_overriding/2_instance_47_overriding.php:3-5
     ; return  [] RANGE[0..0]
0000 CV0($b) = RECV 1
0001 RETURN CV0($b)
0002 RETURN null

child_class::F:
     ; (lines=3, args=1, vars=1, tmps=0)
     ; (before optimizer)
     ; /.../PHP/47_overriding/2_instance_47_overriding/2_instance_47_overriding.php:9-11
     ; return  [] RANGE[0..0]
0000 CV0($b) = RECV 1
0001 RETURN string("safe")
0002 RETURN null
```

</details>

<details markdown="1">
<summary>

### Discovery
</summary>

The rule would be perfect, if we could check for inheritance

```scala
// Get all classes and all the methods within this classes as a list of arrays with two elements [[<class>, <method>], [<class>, <method>]]
val allClassesAndMethods = cpg.method.astParentType("TYPE_DECL").fullName.l.map(x => x.split("::")).filter(x => x.length > 1)
// Get all classnames, that implement the same method as any other class
val classNames = allClassesAndMethods.flatMap(a => allClassesAndMethods.filter(b => b(1) == a(1) && b(0) != a(0)).map(b => (a(0), b(1)))).toSet
val x47 = (name, "47_overriding_iall", cpg.method.filter(node => classNames.contains((node.astParentFullName, node.name))).location.toJson);
```

| discovery method   | expected accuracy   |
|--------------------|---------------------|
| joern              | FP                  |

</details>

<details markdown="1"open>
<summary>

### Measurement
</summary>

| Tool        | Comm_1   | Ground Truth   |
|-------------|----------|----------------|
| 22 May 2023 | no       | no             |

</details>

</details>

</details>
